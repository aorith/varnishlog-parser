package content

import (
	"fmt"
	"strings"

	"github.com/aorith/varnishlog-parser/vsl"
	"github.com/aorith/varnishlog-parser/vsl/tag"
	"github.com/aorith/varnishlog-parser/pkg/render"
)

type ReqBuilderForm struct {
	Scheme    string
	Received  bool   // Use received headers
	Excluded  string // Excluded headers, split by comma
	ConnectTo string
}

templ ReqBuilderTab(txsSet vsl.TransactionSet) {
	<div id="tabRequest" class="tabcontent">
		<p>Here you can generate commands with <a href="https://curl.se/" target="_blank">curl</a> and other tools based on parsed VSL transaction tags. For POST/PUT requests, <b>body is not available</b> in varnishlog and wonâ€™t be included.</p>
		<form
			class="simple-form"
			hx-post="reqbuilder/"
			hx-target="#reqBuilderResults"
			hx-swap="innerHTML settle:0.3s"
			hx-include="[name='logs']"
		>
			<fieldset>
				<legend>Scheme:</legend>
				<label>
					<input type="radio" name="scheme" value="auto" checked/>
					Auto
				</label>
				<label>
					<input type="radio" name="scheme" value="http://"/>
					Http
				</label>
				<label>
					<input type="radio" name="scheme" value="https://"/>
					Https
				</label>
			</fieldset>
			<br/>
			<fieldset>
				<legend>Headers:</legend>
				<label title="Headers as originally sent by the client or backend">
					<input type="radio" name="headers" value="received" checked/>
					Received
				</label>
				<label title="Headers after VCL processing (rewrites, additions, removals)">
					<input type="radio" name="headers" value="processed"/>
					VCL Processed
				</label>
				<br/>
				<br/>
				<label>
					Excluded headers:
					<input type="text" name="excluded" placeholder="header1, header2, ..." value=""/>
				</label>
			</fieldset>
			<br/>
			<fieldset>
				<legend>Connect To: </legend>
				<label>
					<input type="radio" name="connectTo" value="auto" checked/> Auto
				</label>
				<label>
					<input type="radio" name="connectTo" value="none"/> None
				</label>
				<br/>
				<br/>
				<label>
					<input type="radio" name="connectTo" value="backend"/> Backend:
					<br/>
					<select id="transactionBackend" name="transactionBackend">
						for _, tx := range txsSet.Transactions() {
							if tx.Type() == vsl.TxTypeBereq {
								<option value={ getBackend(tx) }>{ tx.TXID() } ({ getBackend(tx) })</option>
							}
						}
					</select>
				</label>
				<br/>
				<br/>
				<label>
					<input type="radio" name="connectTo" value="custom"/> Custom:
					<input type="text" name="custom" pattern="^.+:[0-9]+$" placeholder="<HOST/IP>:<PORT>"/>
				</label>
			</fieldset>
			<br/>
			<button class="btn loading">Generate</button>
		</form>
		<br/>
		<div id="reqBuilderResults"></div>
	</div>
}

templ ReqBuild(txsSet vsl.TransactionSet, f ReqBuilderForm) {
	<div class="fade-me-in">
		for _, tx := range txsSet.Transactions() {
			if tx.Type() != vsl.TxTypeSession {
				<h3>{ tx.TXID() }</h3>
				<pre>
					<code>
						@templ.Raw(curlCommand(tx, f))
					</code>
				</pre>
			}
		}
	</div>
}

func curlCommand(tx *vsl.Transaction, f ReqBuilderForm) string {
	var backend *render.Backend

	switch f.ConnectTo {
	case "none":
		backend = nil
	case "auto":
		if tx.Type() == vsl.TxTypeBereq {
			br := tx.RecordByTag(tag.BackendOpen, false)
			bo := br.(vsl.BackendOpenRecord)
			host, port, err := render.ParseBackend(fmt.Sprintf("%s:%d", bo.RemoteAddr().String(), bo.RemotePort()))
			if err != nil {
				return "error parsing backend: " + err.Error()
			}
			backend = render.NewBackend(host, port)
		}
	default:
		host, port, err := render.ParseBackend(f.ConnectTo)
		if err != nil {
			return "error parsing backend: " + err.Error()
		}
		backend = render.NewBackend(host, port)
	}

	// Parse optional excluded headers
	excluded := []string{}
	if f.Excluded != "" {
		parts := strings.Split(f.Excluded, ",")
		for _, h := range parts {
			name := vsl.CanonicalHeaderName(strings.TrimSpace(h))
			excluded = append(excluded, name)
		}
	}

	httpReq, err := render.NewHTTPRequest(tx, f.Received, excluded)
	if err != nil {
		return "error generating curl command: " + err.Error()
	}

	return httpReq.CurlCommand(f.Scheme, backend)
}

func getBackend(t *vsl.Transaction) string {
	r := t.RecordByTag(tag.BackendOpen, true)
	if r == nil {
		return "none"
	}
	record := r.(vsl.BackendOpenRecord)
	return fmt.Sprintf("%s:%d", record.RemoteAddr().String(), record.RemotePort())
}
