package content

import (
	"fmt"
	"strings"

	"github.com/aorith/varnishlog-parser/vsl"
	"github.com/aorith/varnishlog-parser/vsl/tag"
)

const (
	SendToDomain = iota
	SendToBackend
	SendToLocalhost
	SendToCustom
)

type ReqBuilderForm struct {
	TXID            string
	HTTPS           bool
	OriginalHeaders bool
	OriginalURL     bool
	ResolveTo       int
	CustomResolve   string
}

templ ReqBuilderTab(txsSet vsl.TransactionSet) {
	<div id="tabRequest" class="tabcontent">
		<p>Here you can generate commands with <a href="https://curl.se/" target="_blank">curl</a> and other tools based on parsed VSL transaction tags. For POST/PUT requests, <b>body is not available</b> in varnishlog and wonâ€™t be included.</p>
		<form
			class="simple-form"
			hx-post="reqbuilder/"
			hx-target="#reqBuilderResults"
			hx-swap="innerHTML settle:0.3s"
			hx-include="[name='logs']"
		>
			<fieldset>
				<legend>Transaction: </legend>
				<select id="transactionSelect" name="transaction">
					for _, tx := range txsSet.Transactions() {
						if tx.Type() != vsl.TxTypeSession {
							<option value={ tx.TXID() }>{ tx.TXID() }</option>
						}
					}
				</select>
			</fieldset>
			<br/>
			<fieldset>
				<legend>Protocol: </legend>
				<label>
					<input type="checkbox" name="https" checked/> https
				</label>
			</fieldset>
			<fieldset>
				<legend>URL: </legend>
				<label>
					<input type="radio" name="urlType" value="original" checked/> Original
				</label>
				<label>
					<input type="radio" name="urlType" value="final"/> After VCL
				</label>
			</fieldset>
			<fieldset>
				<legend>Headers: </legend>
				<label>
					<input type="radio" name="headerType" value="original" checked/> Original
				</label>
				<label>
					<input type="radio" name="headerType" value="final"/> After VCL
				</label>
			</fieldset>
			<br/>
			<fieldset>
				<legend>Send To: </legend>
				<label>
					<input type="radio" name="sendTo" value="domain" checked/> Domain
				</label>
				<label>
					<input type="radio" name="sendTo" value="localhost"/> Localhost
				</label>
				<br/>
				<br/>
				<label>
					<input type="radio" name="sendTo" value="backend"/> Backend:
					<br/>
					<select id="transactionBackend" name="transactionBackend">
						for _, tx := range txsSet.Transactions() {
							if tx.Type() == vsl.TxTypeBereq {
								<option value={ getBackend(tx) }>{ tx.TXID() } ({ getBackend(tx) })</option>
							}
						}
					</select>
				</label>
				<br/>
				<br/>
				<label>
					<input type="radio" name="sendTo" value="custom"/> Custom:
					<input type="text" name="customResolve" pattern=".*:.*" placeholder="<IPADDR>:<PORT>"/>
				</label>
			</fieldset>
			<br/>
			<button class="btn loading">Generate</button>
		</form>
		<br/>
		<div id="reqBuilderResults"></div>
	</div>
}

templ ReqBuild(txsSet vsl.TransactionSet, tx *vsl.Transaction, f ReqBuilderForm) {
	<div class="fade-me-in">
		<h3>curl</h3>
		<pre>
			<code>
				@templ.Raw(curlCommand(tx, f))
			</code>
		</pre>
	</div>
}

func curlCommand(t *vsl.Transaction, f ReqBuilderForm) string {
	var s strings.Builder

	hostHdr := t.ReqHeaders().Get("host", f.OriginalHeaders)
	url := ""
	method := ""
	if t.Type() == vsl.TxTypeRequest {
		url = t.RecordValueByTag(tag.ReqURL, f.OriginalURL)
		method = t.RecordValueByTag(tag.ReqMethod, true)
	} else {
		url = t.RecordValueByTag(tag.BereqURL, f.OriginalURL)
		method = t.RecordValueByTag(tag.BereqMethod, true)
	}

	port := "80"
	protocol := "http"
	if f.HTTPS {
		port = "443"
		protocol = "https"
	}
	s.WriteString(fmt.Sprintf(`curl "%s://%s%s"`+" \\\n", protocol, hostHdr, url))

	switch method {
	case "GET":
		// Nothing
	case "POST", "PUT":
		s.WriteString("    -X " + method + " \\\n")
		s.WriteString("    -d '' \\\n")
	default:
		s.WriteString("    -X " + method + " \\\n")
	}

	// Add headers
	var values []vsl.HdrValue
	for _, header := range t.ReqHeaders() {
		values = header.Values(f.OriginalHeaders)
		for _, value := range values {
			if header.Name() == vsl.HdrNameHost || (f.OriginalHeaders && value.State() != vsl.HdrStateReceived) {
				continue
			}
			hdrVal := strings.ReplaceAll(value.Value(), `"`, `\"`)
			s.WriteString(fmt.Sprintf(`    -H "%s: %s" \`+"\n", header.Name(), hdrVal))
		}
	}

	// Fixed options
	s.WriteString("    -s -k -v -o /dev/null")

	// Optional resolve
	switch f.ResolveTo {
	case SendToLocalhost:
		s.WriteString(" \\\n    --resolve " + hostHdr + ":" + port + ":127.0.0.1")
	case SendToBackend, SendToCustom:
		custom := strings.SplitN(f.CustomResolve, ":", 2)
		if custom[0] == "none" {
			return "Backed address not found for selected transaction."
		}
		if len(custom) < 2 {
			return "Incorrect backend address."
		}
		s.WriteString(" \\\n    --resolve " + hostHdr + ":" + custom[1] + ":" + custom[0])

		if (f.HTTPS && custom[1] == "80") || (!f.HTTPS && custom[1] == "443") {
			s.WriteString("\n\n# Incorrect protocol selected?")
		}
	}

	return s.String()
}

func getBackend(t *vsl.Transaction) string {
	r := t.RecordByTag(tag.BackendOpen, true)
	if r == nil {
		return "none"
	}
	record := r.(vsl.BackendOpenRecord)
	return fmt.Sprintf("%s:%d", record.RemoteAddr().String(), record.RemotePort())
}
